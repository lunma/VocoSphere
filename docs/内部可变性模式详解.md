# Rust å†…éƒ¨å¯å˜æ€§æ¨¡å¼è¯¦è§£

## é—®é¢˜èƒŒæ™¯

åœ¨æ—¥å¿—ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªç»å…¸çš„ Rust è®¾è®¡é—®é¢˜ï¼š

```rust
pub struct TauriLogger {
    app_handle: Mutex<Option<AppHandle>>,  // ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ
    level: LevelFilter,
}
```

## æ ¸å¿ƒé—®é¢˜

### 1. ç”Ÿå‘½å‘¨æœŸä¸åŒ¹é…

```rust
// æ—¶é—´çº¿ï¼š
// T1: åˆ›å»º TauriLoggerï¼ˆé€šè¿‡ LazyLockï¼‰
static LOGGER: LazyLock<TauriLogger> = LazyLock::new(|| {
    TauriLogger::new(LevelFilter::Debug)  // âŒ è¿™æ—¶è¿˜æ²¡æœ‰ AppHandle
});

// T2: åº”ç”¨å¯åŠ¨ï¼Œè·å¾— AppHandle
.setup(|app| {
    logger::init_logger(app.handle().clone());  // âœ… ç°åœ¨æœ‰äº† AppHandle
    Ok(())
})

// T3: ä½¿ç”¨æ—¥å¿—
log::info!("Hello");  // âœ… éœ€è¦ç”¨ AppHandle å‘é€åˆ°å‰ç«¯
```

**é—®é¢˜ï¼š** åˆ›å»ºæ—¶æ²¡æœ‰ AppHandleï¼Œä½¿ç”¨æ—¶éœ€è¦ AppHandle

**è§£å†³æ–¹æ¡ˆï¼š** `Option<AppHandle>` - åˆå§‹ä¸º `None`ï¼Œåé¢è®¾ç½®ä¸º `Some`

### 2. Trait æ–¹æ³•åªæœ‰ä¸å¯å˜å¼•ç”¨

`log::Log` trait çš„å®šä¹‰ï¼š

```rust
pub trait Log: Sync + Send {
    fn enabled(&self, metadata: &Metadata) -> bool;
    fn log(&self, record: &Record);  // âš ï¸ åªæœ‰ &selfï¼Œä¸æ˜¯ &mut self
    fn flush(&self);
}
```

æˆ‘ä»¬çš„å®ç°ï¼š

```rust
impl log::Log for TauriLogger {
    fn log(&self, record: &Record) {  // âš ï¸ åªèƒ½æ¥æ”¶ &self
        // ä½†æˆ‘ä»¬éœ€è¦è®¿é—®ï¼ˆå¯èƒ½è¢«ä¿®æ”¹çš„ï¼‰app_handle
        // æ€ä¹ˆåŠï¼ŸğŸ¤”
    }
}
```

**é—®é¢˜ï¼š** åªæœ‰ä¸å¯å˜å¼•ç”¨ `&self`ï¼Œä½†éœ€è¦è®¿é—®å¯å˜çš„å†…éƒ¨çŠ¶æ€

**è§£å†³æ–¹æ¡ˆï¼š** `Mutex` æä¾›**å†…éƒ¨å¯å˜æ€§**ï¼ˆInterior Mutabilityï¼‰

### 3. å¤šçº¿ç¨‹è®¿é—®

```rust
// çº¿ç¨‹ 1
log::info!("Message from thread 1");

// çº¿ç¨‹ 2
log::warn!("Message from thread 2");

// çº¿ç¨‹ 3
log::error!("Message from thread 3");

// æ‰€æœ‰çº¿ç¨‹å¯èƒ½åŒæ—¶è®¿é—® LOGGER
```

**é—®é¢˜ï¼š** å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ®

**è§£å†³æ–¹æ¡ˆï¼š** `Mutex` æä¾›çº¿ç¨‹å®‰å…¨çš„ç‹¬å è®¿é—®

## é€å±‚è§£æ

### ğŸ”¹ ç¬¬ä¸€å±‚ï¼šOption\<AppHandle\>

```rust
app_handle: Option<AppHandle>
```

**ä½œç”¨ï¼š** è¡¨ç¤º"å¯èƒ½æœ‰ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰"

**ç”Ÿå‘½å‘¨æœŸï¼š**
```
åˆå§‹åŒ–æ—¶: None
    â†“
åº”ç”¨å¯åŠ¨å: Some(AppHandle)
    â†“
è¿è¡Œæ—¶ä½¿ç”¨: å§‹ç»ˆæ˜¯ Some(AppHandle)
```

**ä»£ç ç¤ºä¾‹ï¼š**
```rust
// åˆ›å»ºæ—¶
pub fn new(level: LevelFilter) -> Self {
    Self {
        app_handle: None,  // è¿˜æ²¡æœ‰
        level,
    }
}

// è®¾ç½®
pub fn set_app_handle(&mut self, handle: AppHandle) {
    self.app_handle = Some(handle);  // ç°åœ¨æœ‰äº†
}

// ä½¿ç”¨
if let Some(ref app) = self.app_handle {
    app.emit("log-message", &log_msg);
}
```

### ğŸ”¹ ç¬¬äºŒå±‚ï¼šMutex<Option\<AppHandle\>>

```rust
app_handle: Mutex<Option<AppHandle>>
```

**ä½œç”¨ï¼š** å†…éƒ¨å¯å˜æ€§ + çº¿ç¨‹å®‰å…¨

**ä¸ºä»€ä¹ˆéœ€è¦ Mutexï¼Ÿ**

```rust
// âŒ æ²¡æœ‰ Mutex çš„æƒ…å†µ
impl log::Log for TauriLogger {
    fn log(&self, record: &Record) {  // åªæœ‰ &self
        // ç¼–è¯‘é”™è¯¯ï¼æ— æ³•è®¿é—®å¯å˜çš„ app_handle
        if let Some(ref app) = self.app_handle {
            // ...
        }
    }
}

// âœ… ä½¿ç”¨ Mutex
impl log::Log for TauriLogger {
    fn log(&self, record: &Record) {
        // é€šè¿‡ Mutex è·å–å†…éƒ¨è®¿é—®æƒ
        if let Ok(app_guard) = self.app_handle.lock() {
            if let Some(ref app) = *app_guard {
                app.emit("log-message", &log_msg);  // æˆåŠŸï¼
            }
        }
    }
}
```

**å†…éƒ¨å¯å˜æ€§æ¨¡å¼ï¼š**

```rust
// Rust çš„æ‰€æœ‰æƒè§„åˆ™ï¼š
// 1. è¦ä¹ˆæœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ &T
// 2. è¦ä¹ˆæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ &mut T

// Mutex é€šè¿‡è¿è¡Œæ—¶æ£€æŸ¥æ‰“ç ´è¿™ä¸ªé™åˆ¶ï¼š
let mutex = Mutex::new(data);

// é€šè¿‡ä¸å¯å˜å¼•ç”¨è·å–å¯å˜è®¿é—®æƒï¼
fn use_mutex(m: &Mutex<Data>) {  // ä¸å¯å˜å¼•ç”¨
    let mut guard = m.lock().unwrap();
    *guard = new_data;  // å¯ä»¥ä¿®æ”¹ï¼
}
```

### ğŸ”¹ ç¬¬ä¸‰å±‚ï¼ˆå·²ç§»é™¤ï¼‰ï¼šArc<Mutex<Option\<AppHandle\>>>

```rust
// âŒ ä¹‹å‰çš„é”™è¯¯è®¾è®¡
app_handle: Arc<Mutex<Option<AppHandle>>>

// Arc çš„ä½œç”¨ï¼šå…±äº«æ‰€æœ‰æƒ
let shared = Arc::new(data);
let clone1 = shared.clone();  // å¼•ç”¨è®¡æ•° +1
let clone2 = shared.clone();  // å¼•ç”¨è®¡æ•° +1
```

**ä¸ºä»€ä¹ˆä¸éœ€è¦ Arcï¼Ÿ**

```rust
// åœºæ™¯åˆ†æï¼š
static LOGGER: LazyLock<TauriLogger> = ...;

// åªæœ‰ä¸€ä¸ª TauriLogger å®ä¾‹ï¼Œå­˜å‚¨åœ¨ static ä¸­
// ä¸éœ€è¦å…‹éš†æˆ–å…±äº«æ‰€æœ‰æƒ
// æ‰€æœ‰çº¿ç¨‹éƒ½è®¿é—®åŒä¸€ä¸ª static å®ä¾‹
// å› æ­¤ Arc æ˜¯å¤šä½™çš„ï¼
```

**ä»€ä¹ˆæ—¶å€™éœ€è¦ Arcï¼Ÿ**

```rust
// ä¾‹å­ï¼šå¤šä¸ªæ‰€æœ‰è€…å…±äº«æ•°æ®
let data = Arc::new(Mutex::new(vec![1, 2, 3]));

// çº¿ç¨‹ 1 è·å–æ‰€æœ‰æƒ
let data1 = data.clone();
thread::spawn(move || {
    let mut d = data1.lock().unwrap();
    d.push(4);
});

// çº¿ç¨‹ 2 è·å–æ‰€æœ‰æƒ
let data2 = data.clone();
thread::spawn(move || {
    let mut d = data2.lock().unwrap();
    d.push(5);
});

// ä¸»çº¿ç¨‹ä¹ŸæŒæœ‰æ‰€æœ‰æƒ
let d = data.lock().unwrap();
println!("{:?}", *d);
```

## å®Œæ•´çš„æ¼”åŒ–è¿‡ç¨‹

### ç‰ˆæœ¬ 1ï¼šæœ€ç®€å•çš„å°è¯•ï¼ˆâŒ å¤±è´¥ï¼‰

```rust
pub struct TauriLogger {
    app_handle: AppHandle,  // âŒ åˆå§‹åŒ–æ—¶æ²¡æœ‰ï¼
}

// ç¼–è¯‘é”™è¯¯ï¼šåˆ›å»ºæ—¶æ— æ³•æä¾› AppHandle
```

### ç‰ˆæœ¬ 2ï¼šæ·»åŠ  Optionï¼ˆâŒ éƒ¨åˆ†æˆåŠŸï¼‰

```rust
pub struct TauriLogger {
    app_handle: Option<AppHandle>,  // âœ… å¯ä»¥æ˜¯ None
}

impl log::Log for TauriLogger {
    fn log(&self, record: &Record) {
        // âŒ ç¼–è¯‘é”™è¯¯ï¼šcannot borrow as mutable
        if let Some(ref app) = self.app_handle {
            // ...
        }
    }
}
```

### ç‰ˆæœ¬ 3ï¼šæ·»åŠ  Mutexï¼ˆâœ… æˆåŠŸï¼‰

```rust
pub struct TauriLogger {
    app_handle: Mutex<Option<AppHandle>>,  // âœ… å®Œç¾ï¼
}

impl log::Log for TauriLogger {
    fn log(&self, record: &Record) {
        // âœ… æˆåŠŸï¼šé€šè¿‡ Mutex è·å–è®¿é—®æƒ
        if let Ok(guard) = self.app_handle.lock() {
            if let Some(ref app) = *guard {
                app.emit("log-message", &log_msg);
            }
        }
    }
}
```

### ç‰ˆæœ¬ 4ï¼šè¯¯åŠ  Arcï¼ˆâŒ å¤šä½™ï¼‰

```rust
pub struct TauriLogger {
    app_handle: Arc<Mutex<Option<AppHandle>>>,  // âŒ Arc å¤šä½™
}
```

### æœ€ç»ˆç‰ˆæœ¬ï¼šç§»é™¤ Arcï¼ˆâœ… æœ€ä¼˜ï¼‰

```rust
pub struct TauriLogger {
    app_handle: Mutex<Option<AppHandle>>,  // âœ… ç®€æ´ä¸”æ­£ç¡®
}
```

## å†…éƒ¨å¯å˜æ€§çš„å…¶ä»–æ–¹æ¡ˆ

### 1. Cell<T> - å•çº¿ç¨‹

```rust
use std::cell::Cell;

struct Counter {
    count: Cell<u32>,  // å•çº¿ç¨‹çš„å†…éƒ¨å¯å˜æ€§
}

impl Counter {
    fn increment(&self) {  // æ³¨æ„ï¼š&self
        let current = self.count.get();
        self.count.set(current + 1);
    }
}

// âŒ Cell ä¸æ˜¯ Syncï¼Œä¸èƒ½ç”¨äºå¤šçº¿ç¨‹
```

### 2. RefCell<T> - å•çº¿ç¨‹ + å€Ÿç”¨æ£€æŸ¥

```rust
use std::cell::RefCell;

struct Logger {
    messages: RefCell<Vec<String>>,  // è¿è¡Œæ—¶å€Ÿç”¨æ£€æŸ¥
}

impl Logger {
    fn log(&self, msg: String) {
        self.messages.borrow_mut().push(msg);  // è¿è¡Œæ—¶æ£€æŸ¥
    }
}

// âŒ RefCell ä¸æ˜¯ Syncï¼Œä¸èƒ½ç”¨äºå¤šçº¿ç¨‹
```

### 3. Mutex<T> - å¤šçº¿ç¨‹ï¼ˆæˆ‘ä»¬çš„é€‰æ‹©ï¼‰

```rust
use std::sync::Mutex;

struct Logger {
    messages: Mutex<Vec<String>>,  // çº¿ç¨‹å®‰å…¨
}

impl Logger {
    fn log(&self, msg: String) {
        if let Ok(mut msgs) = self.messages.lock() {
            msgs.push(msg);
        }
    }
}

// âœ… Mutex æ˜¯ Syncï¼Œå¯ä»¥ç”¨äºå¤šçº¿ç¨‹
```

### 4. RwLock<T> - è¯»å†™é”

```rust
use std::sync::RwLock;

struct Cache {
    data: RwLock<HashMap<String, String>>,
}

impl Cache {
    fn get(&self, key: &str) -> Option<String> {
        self.data.read().unwrap().get(key).cloned()  // å¤šä¸ªè¯»è€…
    }
    
    fn set(&self, key: String, value: String) {
        self.data.write().unwrap().insert(key, value);  // ç‹¬å å†™å…¥
    }
}

// âœ… é€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯
```

## æ€§èƒ½è€ƒè™‘

### Mutex çš„å¼€é”€

```rust
// æ¯æ¬¡ lock() éƒ½æœ‰å¼€é”€ï¼š
if let Ok(guard) = self.app_handle.lock() {
    // 1. å°è¯•è·å–é”
    // 2. å¦‚æœè¢«å ç”¨ï¼Œç­‰å¾…
    // 3. è·å–æˆåŠŸï¼Œæ‰§è¡Œä»£ç 
    // 4. guard ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”
}
```

### ä¼˜åŒ–å»ºè®®

```rust
// âŒ ä¸å¥½ï¼šåœ¨é”å†…åšè€—æ—¶æ“ä½œ
if let Ok(guard) = self.data.lock() {
    heavy_computation(&guard);  // é˜»å¡å…¶ä»–çº¿ç¨‹ï¼
}

// âœ… å¥½ï¼šæœ€å°åŒ–é”æŒæœ‰æ—¶é—´
let data_clone = {
    let guard = self.data.lock().unwrap();
    guard.clone()  // å¿«é€Ÿå…‹éš†ï¼Œç«‹å³é‡Šæ”¾é”
};
heavy_computation(&data_clone);  // åœ¨é”å¤–æ‰§è¡Œ
```

## æ€»ç»“

### Mutex<Option\<AppHandle\>> çš„ä¸‰ä¸ªä½œç”¨

| å±‚çº§ | ä½œç”¨ | è§£å†³çš„é—®é¢˜ |
|------|------|----------|
| **Option** | è¡¨ç¤º"å¯é€‰" | åˆå§‹åŒ–æ—¶æ²¡æœ‰ AppHandle |
| **Mutex** | å†…éƒ¨å¯å˜æ€§ + çº¿ç¨‹å®‰å…¨ | trait æ–¹æ³•åªæœ‰ &self + å¤šçº¿ç¨‹è®¿é—® |
| ~~Arc~~ | ~~å…±äº«æ‰€æœ‰æƒ~~ | ~~ä¸éœ€è¦ï¼Œå·²ç§»é™¤~~ |

### å…³é”®æ¦‚å¿µ

1. **å†…éƒ¨å¯å˜æ€§**ï¼šé€šè¿‡ä¸å¯å˜å¼•ç”¨ä¿®æ”¹å†…éƒ¨æ•°æ®
2. **çº¿ç¨‹å®‰å…¨**ï¼šMutex ä¿è¯å¤šçº¿ç¨‹å®‰å…¨è®¿é—®
3. **å»¶è¿Ÿåˆå§‹åŒ–**ï¼šOption å¤„ç†åˆå§‹æ—¶ä¸å¯ç”¨çš„æƒ…å†µ

### æœ€ä½³å®è·µ

- âœ… ä½¿ç”¨ `Mutex<T>` è€Œé `Arc<Mutex<T>>`ï¼ˆé™¤éçœŸçš„éœ€è¦å…±äº«æ‰€æœ‰æƒï¼‰
- âœ… æœ€å°åŒ–é”æŒæœ‰æ—¶é—´
- âœ… è€ƒè™‘ä½¿ç”¨ `RwLock` ä»£æ›¿ `Mutex`ï¼ˆè¯»å¤šå†™å°‘çš„åœºæ™¯ï¼‰
- âœ… æ·»åŠ æ¸…æ™°çš„æ³¨é‡Šè¯´æ˜è®¾è®¡æ„å›¾

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„æ—¥å¿—ç³»ç»Ÿä½¿ç”¨ `Mutex<Option<AppHandle>>` çš„å®Œæ•´åŸå› ï¼ğŸ¯

